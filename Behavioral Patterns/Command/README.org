:PROPERTIES:
:ID:       3e2bacea-346e-4c06-903a-f2805a7181b5
:END:
#+title: Command Pattern

The command pattern is a [[id:76d25eaf-b3c8-407f-bd77-80d02942ebac][behavioral patterns]] that turns a request into a stand-alone object
that contains all information about the request. This transformation lets you pass requests
as a method arguments, delay or queue a request’s execution, and support undoable
operations.

/Also known as; Action, Transaction/

* Problem
Sometimes it's necessary to issue requests to objects without knowing anything about the operation being
requested or the receiver of the request. For example, user interface toolkits include objects like buttons
and menus that carry out a request in response to user input. But the toolkit can't implement the request
explicitly in the button or menu, because only applications that use the toolkit know what should be done on
which object. As toolkit designers we have no way of knowing the receiver of the request or the operations
that will carry it out.
* Naive Solution
/reference: https://refactoring.guru/design-patterns/command/

Imagine that you’re working on a new text-editor app. Your current task is to create a toolbar with a bunch of
buttons for various operations of the editor. You created a neat Button class that can be used for
buttons on the toolbar, as well as for generic buttons in various dialog.

While all of these buttons look similar, they’re all supposed to do different things. Where would you put the
code for the various click handlers of these buttons? The simplest solution is to create tons of subclasses
for each place where the button is used. These subclasses would contain the code that would have to be
executed on a button click.

[[https://user-images.githubusercontent.com/74098495/197915759-2d6b0fb4-55ea-442a-bc7c-fac7c6046062.png]]


The results so far are 1. hardened & duplicate code: we have the main functionalities hard coupled to our
widgets (buttons), which kills:
1. Reusablality
   You have to rewrite (copy) all the code again in any equivalent function place, for example; if you are to
   add feature to copy text with ~Ctrl-C~ keybindings, you will have to copy the functional code from the
   widget that is responsible for copying
2. Maintainability
   If you did (copy the functional code), then everytime you are going to fix a bug, you will have to fix it
   twice (or maybe more).

/Recall single responsibility principle from Solid/

   and maintainability

# Local Variables:
# fill-column: 110
# End:
* Solution

The Command pattern lets toolkit objects make requests of unspecified application objects by turning the
request itself into an object. This object can be stored and passed around like other objects. The key to this
pattern is an abstract Command class, which declares an interface for executing operations. In the simplest
form this interface includes an abstract Execute operation. Concrete Command subclasses specify a
receiver-action pair by storing the receiver as an instance variable and by implementing Execute to invoke the
request. The receiver has the knowledge required to carry out the request.

This would both imply and enforce the usage of more clean architecture; you will have to separate the
functional implementation from the GUI.

[[https://user-images.githubusercontent.com/74098495/197919618-ac4e165c-41d5-469e-9bc6-d337eff5fd65.png]]


The application configures each ~Menultem~ with an instance of a concrete Command subclass. When the user
selects a ~Menultem~, the ~Menultem~ calls Execute on its command, and Execute carries out the operation.
~Menultem~ (s) don't know which subclass of Command they use. Command subclasses store the receiver of the
request and invoke one or more operations on the receiver.
* Structure


#+begin_src plantuml :file symbols.png

/' COMMAND '/

@startuml

class Client

class Invoker

class Receiver {
    + action()
}

class Command {
    + execute()
}

class ConcreteCommand {
    + execute()
}

hide empty members

Client -> Invoker
Client --> Receiver
Invoker *-- Command
Client ..> ConcreteCommand
Receiver -> ConcreteCommand
ConcreteCommand -|> Command

note as N1
    <b><color:royalBlue>Command</color></b>
    <b>Type:</b> Behavioral
    Encapsulate a request as an object,
    thereby letting you parameterize clients
    with different requests, queue or log
    requests, and support undoable operations.
end note
skinparam backgroundcolor transparent
@enduml
#+end_src

[[file:symbols.png]]


+ ~Client~
  - creates a ConcreteCommand object and sets its receiver.
+ ~Command~
  - declares an interface for executing an operation.
  - implements Execute by invoking the corresponding operation(s) on Receiver.

+ ~ConcreteCommand~
  + defines a binding between a Receiver object and an action.
  + implements Execute by invoking the corresponding operation(s) on Receiver.

+ ~Invoker~
  - asks the command to carry out the request

# Local Variables:
# fill-column: 110
# End:
